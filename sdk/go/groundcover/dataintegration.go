// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package groundcover

import (
	"context"
	"reflect"

	"errors"
	"github.com/groundcover-com/pulumi-groundcover/sdk/go/groundcover/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// DataIntegration resource for managing groundcover's integrations with external services such as cloud providers, databases and more. This resource is composed of general metadata on the integration and a specific configuration per data source. Navigate to the relevant nested schema according to your specific needs.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/groundcover-com/pulumi-groundcover/sdk/go/groundcover"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"name":      "test-cloudwatch",
//				"version":   1,
//				"stsRegion": "us-east-1",
//				"regions": []string{
//					"us-east-1",
//					"us-east-2",
//				},
//				"roleArn": "arn:aws:iam::123456789012:role/test-role",
//				"awsMetrics": []map[string]interface{}{
//					map[string]interface{}{
//						"namespace": "AWS/EC2",
//						"metrics": []map[string]interface{}{
//							map[string]interface{}{
//								"name": "CPUUtilization",
//								"statistics": []string{
//									"Average",
//								},
//							},
//						},
//					},
//				},
//				"labelSettings": map[string]interface{}{
//					"extraLabels": map[string]interface{}{
//						"env": "prod",
//					},
//				},
//				"scrapeInterval": 300000000000,
//				"exporters": []string{
//					"prometheus",
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			// Example: CloudWatch DataIntegration
//			// For a full list of supported AWS metrics and statistics, visit the official CloudWatch documentation:
//			// https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/aws-services-cloudwatch-metrics.html
//			cloudwatchExample, err := groundcover.NewDataintegration(ctx, "cloudwatchExample", &groundcover.DataintegrationArgs{
//				Type:     pulumi.String("cloudwatch"),
//				Config:   pulumi.String(json0),
//				IsPaused: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON1, err := json.Marshal(map[string]interface{}{
//				"name":                 "test-gcp",
//				"version":              1,
//				"enabled":              true,
//				"targetServiceAccount": "demo@gcp-demo-project.iam.gserviceaccount.com",
//				"regions": []string{
//					"us-west1",
//				},
//				"metricPrefixes": []string{
//					"cloudsql.googleapis.com",
//					"compute.googleapis.com",
//				},
//				"projectIDs": []string{
//					"gcp-demo-project",
//				},
//				"scrapeInterval": 300000000000,
//				"exporters": []string{
//					"prometheus",
//				},
//				"labelSettings": map[string]interface{}{
//					"extraLabels": map[string]interface{}{
//						"env": "prod",
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json1 := string(tmpJSON1)
//			// Example: GCP Metrics DataIntegration
//			// For a full list of supported GCP metrics, visit the official GCP documentation:
//			// https://cloud.google.com/monitoring/api/metrics_gcp
//			gcpExample, err := groundcover.NewDataintegration(ctx, "gcpExample", &groundcover.DataintegrationArgs{
//				Type:     pulumi.String("gcpmetrics"),
//				Config:   pulumi.String(json1),
//				IsPaused: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			tmpJSON2, err := json.Marshal(map[string]interface{}{
//				"name":    "Azure demo",
//				"version": 1,
//				"subscriptions": []string{
//					"b3128f7e-54df-4d2e-9c3e-93a4f1f8c9a0",
//				},
//				"regions": []string{
//					"australiaeast",
//				},
//				"azureMetrics": []map[string]interface{}{
//					map[string]interface{}{
//						"resourceType": "Microsoft.Compute/virtualMachines",
//						"metrics": []map[string]interface{}{
//							map[string]interface{}{
//								"name": "Available Memory Bytes",
//							},
//						},
//						"aggregations": []string{
//							"Average",
//							"Maximum",
//							"Minimum",
//						},
//					},
//				},
//				"azureCloudEnvironment": "AzurePublicCloud",
//				"scrapeInterval":        300000000000,
//				"labelSettings": map[string]interface{}{
//					"extraLabels": map[string]interface{}{
//						"env": "prod",
//					},
//				},
//				"exporters": []string{
//					"prometheus",
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json2 := string(tmpJSON2)
//			// Example: Azure Metrics DataIntegration
//			// For a full list of supported Azure metrics, visit the official Azure Monitor documentation:
//			// https://learn.microsoft.com/en-us/azure/azure-monitor/reference/metrics-index
//			azureExample, err := groundcover.NewDataintegration(ctx, "azureExample", &groundcover.DataintegrationArgs{
//				Type:     pulumi.String("azuremetrics"),
//				Config:   pulumi.String(json2),
//				IsPaused: pulumi.Bool(false),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("cloudwatchDataintegrationId", cloudwatchExample.ID())
//			ctx.Export("gcpmetricsDataintegrationId", gcpExample.ID())
//			ctx.Export("azuremetricsDataintegrationId", azureExample.ID())
//			return nil
//		})
//	}
//
// ```
type Dataintegration struct {
	pulumi.CustomResourceState

	// The cluster where the data integration runs. If unspecified, it will run in the backend.
	Cluster pulumi.StringPtrOutput `pulumi:"cluster"`
	// The JSON configuration for the data integration.
	Config pulumi.StringOutput `pulumi:"config"`
	// Whether the data integration is paused. Default: `false`.
	IsPaused pulumi.BoolOutput `pulumi:"isPaused"`
	// The type of data integration (e.g., 'cloudwatch', etc.).
	Type pulumi.StringOutput `pulumi:"type"`
	// The last update timestamp of the data integration configuration.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// The user who last updated the data integration configuration.
	UpdatedBy pulumi.StringOutput `pulumi:"updatedBy"`
}

// NewDataintegration registers a new resource with the given unique name, arguments, and options.
func NewDataintegration(ctx *pulumi.Context,
	name string, args *DataintegrationArgs, opts ...pulumi.ResourceOption) (*Dataintegration, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Config == nil {
		return nil, errors.New("invalid value for required argument 'Config'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Dataintegration
	err := ctx.RegisterResource("groundcover:index/dataintegration:Dataintegration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDataintegration gets an existing Dataintegration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDataintegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DataintegrationState, opts ...pulumi.ResourceOption) (*Dataintegration, error) {
	var resource Dataintegration
	err := ctx.ReadResource("groundcover:index/dataintegration:Dataintegration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Dataintegration resources.
type dataintegrationState struct {
	// The cluster where the data integration runs. If unspecified, it will run in the backend.
	Cluster *string `pulumi:"cluster"`
	// The JSON configuration for the data integration.
	Config *string `pulumi:"config"`
	// Whether the data integration is paused. Default: `false`.
	IsPaused *bool `pulumi:"isPaused"`
	// The type of data integration (e.g., 'cloudwatch', etc.).
	Type *string `pulumi:"type"`
	// The last update timestamp of the data integration configuration.
	UpdatedAt *string `pulumi:"updatedAt"`
	// The user who last updated the data integration configuration.
	UpdatedBy *string `pulumi:"updatedBy"`
}

type DataintegrationState struct {
	// The cluster where the data integration runs. If unspecified, it will run in the backend.
	Cluster pulumi.StringPtrInput
	// The JSON configuration for the data integration.
	Config pulumi.StringPtrInput
	// Whether the data integration is paused. Default: `false`.
	IsPaused pulumi.BoolPtrInput
	// The type of data integration (e.g., 'cloudwatch', etc.).
	Type pulumi.StringPtrInput
	// The last update timestamp of the data integration configuration.
	UpdatedAt pulumi.StringPtrInput
	// The user who last updated the data integration configuration.
	UpdatedBy pulumi.StringPtrInput
}

func (DataintegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*dataintegrationState)(nil)).Elem()
}

type dataintegrationArgs struct {
	// The cluster where the data integration runs. If unspecified, it will run in the backend.
	Cluster *string `pulumi:"cluster"`
	// The JSON configuration for the data integration.
	Config string `pulumi:"config"`
	// Whether the data integration is paused. Default: `false`.
	IsPaused *bool `pulumi:"isPaused"`
	// The type of data integration (e.g., 'cloudwatch', etc.).
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a Dataintegration resource.
type DataintegrationArgs struct {
	// The cluster where the data integration runs. If unspecified, it will run in the backend.
	Cluster pulumi.StringPtrInput
	// The JSON configuration for the data integration.
	Config pulumi.StringInput
	// Whether the data integration is paused. Default: `false`.
	IsPaused pulumi.BoolPtrInput
	// The type of data integration (e.g., 'cloudwatch', etc.).
	Type pulumi.StringInput
}

func (DataintegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dataintegrationArgs)(nil)).Elem()
}

type DataintegrationInput interface {
	pulumi.Input

	ToDataintegrationOutput() DataintegrationOutput
	ToDataintegrationOutputWithContext(ctx context.Context) DataintegrationOutput
}

func (*Dataintegration) ElementType() reflect.Type {
	return reflect.TypeOf((**Dataintegration)(nil)).Elem()
}

func (i *Dataintegration) ToDataintegrationOutput() DataintegrationOutput {
	return i.ToDataintegrationOutputWithContext(context.Background())
}

func (i *Dataintegration) ToDataintegrationOutputWithContext(ctx context.Context) DataintegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataintegrationOutput)
}

// DataintegrationArrayInput is an input type that accepts DataintegrationArray and DataintegrationArrayOutput values.
// You can construct a concrete instance of `DataintegrationArrayInput` via:
//
//	DataintegrationArray{ DataintegrationArgs{...} }
type DataintegrationArrayInput interface {
	pulumi.Input

	ToDataintegrationArrayOutput() DataintegrationArrayOutput
	ToDataintegrationArrayOutputWithContext(context.Context) DataintegrationArrayOutput
}

type DataintegrationArray []DataintegrationInput

func (DataintegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Dataintegration)(nil)).Elem()
}

func (i DataintegrationArray) ToDataintegrationArrayOutput() DataintegrationArrayOutput {
	return i.ToDataintegrationArrayOutputWithContext(context.Background())
}

func (i DataintegrationArray) ToDataintegrationArrayOutputWithContext(ctx context.Context) DataintegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataintegrationArrayOutput)
}

// DataintegrationMapInput is an input type that accepts DataintegrationMap and DataintegrationMapOutput values.
// You can construct a concrete instance of `DataintegrationMapInput` via:
//
//	DataintegrationMap{ "key": DataintegrationArgs{...} }
type DataintegrationMapInput interface {
	pulumi.Input

	ToDataintegrationMapOutput() DataintegrationMapOutput
	ToDataintegrationMapOutputWithContext(context.Context) DataintegrationMapOutput
}

type DataintegrationMap map[string]DataintegrationInput

func (DataintegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Dataintegration)(nil)).Elem()
}

func (i DataintegrationMap) ToDataintegrationMapOutput() DataintegrationMapOutput {
	return i.ToDataintegrationMapOutputWithContext(context.Background())
}

func (i DataintegrationMap) ToDataintegrationMapOutputWithContext(ctx context.Context) DataintegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DataintegrationMapOutput)
}

type DataintegrationOutput struct{ *pulumi.OutputState }

func (DataintegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Dataintegration)(nil)).Elem()
}

func (o DataintegrationOutput) ToDataintegrationOutput() DataintegrationOutput {
	return o
}

func (o DataintegrationOutput) ToDataintegrationOutputWithContext(ctx context.Context) DataintegrationOutput {
	return o
}

// The cluster where the data integration runs. If unspecified, it will run in the backend.
func (o DataintegrationOutput) Cluster() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Dataintegration) pulumi.StringPtrOutput { return v.Cluster }).(pulumi.StringPtrOutput)
}

// The JSON configuration for the data integration.
func (o DataintegrationOutput) Config() pulumi.StringOutput {
	return o.ApplyT(func(v *Dataintegration) pulumi.StringOutput { return v.Config }).(pulumi.StringOutput)
}

// Whether the data integration is paused. Default: `false`.
func (o DataintegrationOutput) IsPaused() pulumi.BoolOutput {
	return o.ApplyT(func(v *Dataintegration) pulumi.BoolOutput { return v.IsPaused }).(pulumi.BoolOutput)
}

// The type of data integration (e.g., 'cloudwatch', etc.).
func (o DataintegrationOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *Dataintegration) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The last update timestamp of the data integration configuration.
func (o DataintegrationOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Dataintegration) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// The user who last updated the data integration configuration.
func (o DataintegrationOutput) UpdatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *Dataintegration) pulumi.StringOutput { return v.UpdatedBy }).(pulumi.StringOutput)
}

type DataintegrationArrayOutput struct{ *pulumi.OutputState }

func (DataintegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Dataintegration)(nil)).Elem()
}

func (o DataintegrationArrayOutput) ToDataintegrationArrayOutput() DataintegrationArrayOutput {
	return o
}

func (o DataintegrationArrayOutput) ToDataintegrationArrayOutputWithContext(ctx context.Context) DataintegrationArrayOutput {
	return o
}

func (o DataintegrationArrayOutput) Index(i pulumi.IntInput) DataintegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Dataintegration {
		return vs[0].([]*Dataintegration)[vs[1].(int)]
	}).(DataintegrationOutput)
}

type DataintegrationMapOutput struct{ *pulumi.OutputState }

func (DataintegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Dataintegration)(nil)).Elem()
}

func (o DataintegrationMapOutput) ToDataintegrationMapOutput() DataintegrationMapOutput {
	return o
}

func (o DataintegrationMapOutput) ToDataintegrationMapOutputWithContext(ctx context.Context) DataintegrationMapOutput {
	return o
}

func (o DataintegrationMapOutput) MapIndex(k pulumi.StringInput) DataintegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Dataintegration {
		return vs[0].(map[string]*Dataintegration)[vs[1].(string)]
	}).(DataintegrationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DataintegrationInput)(nil)).Elem(), &Dataintegration{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataintegrationArrayInput)(nil)).Elem(), DataintegrationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DataintegrationMapInput)(nil)).Elem(), DataintegrationMap{})
	pulumi.RegisterOutputType(DataintegrationOutput{})
	pulumi.RegisterOutputType(DataintegrationArrayOutput{})
	pulumi.RegisterOutputType(DataintegrationMapOutput{})
}
